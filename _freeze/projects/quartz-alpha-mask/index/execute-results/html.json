{
  "hash": "63176b691822562afafc30b5b7b9afca",
  "result": {
    "markdown": "---\ntitle: Adding Alpha Masks to the Quartz Graphics Device # Warning: changing the title may create a new Discussions thread!\ndescription: \"\" # Optional short description for post on Discussions thread\nauthor: Paul Murrell\noutput: html_document\nexecute:\n  freeze: auto\ncategories: [C, MacOS, Graphics]\ncomments:\n  giscus: \n    repo: \"r-devel/r-project-sprint-2023\"\n    repo-id: \"R_kgDOIhAibA\"\n    category: \"Proposals\"\n    category-id: \"DIC_kwDOIhAibM4CW3GY\"\n    mapping: \"title\"\n    reactions-enabled: true\n    loading: lazy\n---\n\n\n## Background\n\nR version 4.1 added the concept of alpha masks to R graphics, with an interface in the 'grid' graphics system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(grid)\n```\n:::\n\n\nAny shape(s) can be used to create an alpha mask, but the only thing that matters is the opacity of the final result. The mask below is based on a circle, the important part being that it has a semitransparent fill (a line segment is drawn to show that the circle is semitransparent; the line is visible through the circle). Outside the circle, where we have drawn nothing, the mask is fully transparent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nac <- circleGrob(r=.3, gp=gpar(col=NA, fill=rgb(0,0,0,.5)))\namask <- as.mask(ac)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/draw-circle-mask-1.png){width=192}\n:::\n:::\n\n\nWe can apply a mask to affect what happens when we draw other shapes. For example, we will work with the following rectangles, one tall and thin and red and one short and wide and green.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr1 <- rectGrob(width=.2, gp=gpar(fill=2))\nr2 <- rectGrob(height=.2, gp=gpar(fill=3))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/draw-rect-1.png){width=192}\n:::\n:::\n\n\nThe following code draws the red rectangle, then pushes a viewport that enforces the mask (based on the circle), and then draws the green rectangle. The red rectangle is drawn normally, but the mask means that only part of the green rectangle is drawn (where the rectangle and the circlular mask overlap) and that part is only drawn semitransparent (because the mask is semitransparent).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid.rect()\ngrid.draw(r1)\npushViewport(viewport(mask=amask))\ngrid.draw(r2)\npopViewport()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rect-circle-mask-1.png){width=192}\n:::\n:::\n\n\nR version 4.2 added the concept of *luminance* masks. As with alpha masks, we can create a luminance masks with any shape, but what matters is not the opacity of the final result, but the luminance of the final result; whether the mask is black (which corresponds to full transparency), or white (full opacity), or grey (semitransparency).\n\nWe will again work with a mask based on a circle, but this time the circle just has an opaque grey fill (we cannot see the line segment through the circle).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlc <- circleGrob(r=.3, gp=gpar(col=NA, fill=\"grey50\"))\nlmask <- as.mask(lc, type=\"luminance\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/draw-lumi-mask-1.png){width=192}\n:::\n:::\n\n\nThe following code draws the red rectangle, then pushes a viewport with the luminance mask, then draws the green rectangle. The result is the same as for the alpha mask, but this time the result is due to the grey values in the luminance mask, where before the result was due to the opacity value in the alpha mask.\n\nWe have to use the `pdf()` device to demonstrate a luminance mask because the Cairo graphics device that was used for previous images only supports alpha masks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npdf(\"lumi-mask.pdf\", width=2, height=2)\ngrid.rect()\ngrid.draw(r1)\npushViewport(viewport(mask=lmask))\ngrid.draw(r2)\npopViewport()\ndev.off()\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning in system(\"convert -density 96 lumi-mask.pdf lumi-mask.png\"): error in\nrunning command\n```\n:::\n:::\n\n\n![](lumi-mask.png)\n\n## Problem statement\n\nFor R version 4.3, support for luminance masks is being added to the Quartz graphics device in R (`quartz()` on MacOS). Unfortunately, in a reverse of the Cairo graphics device problem, Quartz graphics only supports luminance masks so we have not implemented alpha masks on the `quartz()` device.\n\n## Proposed solution\n\nThe implementation of luminance masks for the `quartz()` device involves creating a greyscale bitmap image and drawing the mask shapes onto that. This happens in the C function `QuartzCreateMask()` (in `R/src/library/grDevices/src/devQuartz.c`). The Quartz function `CGContextClipToMask()` uses that greyscale image to clip output.\n\nThe proposal is that an alpha mask could be implemented by creating an RGBA bitmap image (instead of a greyscale image) for drawing the mask shapes onto and then converting that image to a greyscale one based on the alpha channel of the RGBA image. Once we have a greyscale image from the alpha mask, we can proceed as before.\n\nThe `dev->capabilities()` of the `quartz()` device would also need updating.\n\n## Testing\n\nSome examples of R code and desired output for luminance masks are included in the technical report [\"Luminance Masks in R Graphics\"](https://stattech.wordpress.fos.auckland.ac.nz/2021/12/01/2021-04-luminance-masks-in-r-graphics/) ([faster link](https://protect-au.mimecast.com/s/SkAFCq71EMFpz5z7fZ37by?domain=stat.auckland.ac.nz)).\n\nThe ['gdiff' package](https://cran.rstudio.com/web/packages/gdiff/) can be useful for checking that test output matches control output.\n\n## Project requirements\n\nFamiliarity with C. Though there is a strong template of existing code to work from.\n\nCapability to build R from source (on MacOS).\n\nAbility to find, read, and comprehend Apple Core Graphics documentation, e.g., documentation for [`CGContextClipToMask()`](https://developer.apple.com/documentation/coregraphics/1456497-cgcontextcliptomask)\n\n## Project resources\n\n-   [\"New Features in the R Graphics Engine\"](https://developer.r-project.org/Blog/public/2020/07/15/new-features-in-the-r-graphics-engine/)\n\n-   [\"Luminance Masks in R Graphics\"](https://stattech.wordpress.fos.auckland.ac.nz/2021/12/01/2021-04-luminance-masks-in-r-graphics/).\n\n-   [\"Groups and Paths and Masks in R Graphics\"](https://developer.r-project.org/Blog/public/2021/12/06/groups-and-paths-and-masks-in-r-graphics/index.html)\n\n-   [\"Catching up with R Graphics\"](https://stattech.wordpress.fos.auckland.ac.nz/2020/07/14/2020-04-catching-up-with-r-graphics/)\n\n-   [\"Writing R Extensions\"](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html)\n\n-   [\"R internals\"](https://cran.r-project.org/doc/manuals/r-devel/R-ints.html)\n\n-   Questions can be emailed to [Paul Murrell](mailto:paul@stat.auckland.ac.nz)\n\n## Project outcomes\n\nContribution to the core R code base (would need to be GPL).\n\nExperience with building R from source.\n\nExposure to the design of R graphics devices and the R graphics device API.\n\nExposure to R graphics C code, especially that involving graphics devices (`R/src/include/R_Ext/GraphicsDevice.h`), especially the `quartz()` device (`R/src/library/grDevices/src/devQuartz.c`).\n\n## Reactions and comments\n\n\n```{=html}\n<!-- \nPlease leave the Reactions and comments section\n- a Giscus comment box will be automatically added here \n-->\n```\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}